# MicroserviceBlogs



Sid Phillips
Netflix - How We Build Code

    Netflix Tech Blog’s article, “How We Build Code,” provides a look at how Netflix can build code before deploying it to the cloud, and shows how they can take source code written by a handful of developers and turn it into a deployed service streaming movies to millions upon millions of users. 
    To understand Netflix’s architecture, you first need to understand Spinnaker. Spinnaker is an open-source continuous delivery platform for releasing software changes with high velocity and confidence, and is designed with pluggability (the ease of extending and enhancing cloud deployment models) in mind. 
    A quick overview: Before a piece of code even touches Spinnaker, however, it must go through a number of steps. Code is built and tested locally using Nebula (opinionated set of plugins for gradle), before being pushed to a central git repository. Next, a Jenkins (an open source automation server) job helps to build, test, and package the application for deployment. “The Bakery” helps to facilitate turning source into Amazon Machine Instances (AMIs), and finally Spinnaker pipelines are used to deploy and promote the code changes. I’ll delve into the specifics next.
    First, we begin at the build phase. As mentioned previously, Gradle/Nebula is used to provide reusable and consistent build functionality, along with reducing “boilerplate” code (sections of code that have to be included in many places with little or no alterations).
    Once the code is built and tested locally, we can move on to the Integration phase. The source code is pushed to a private git repository, which triggers a Jenkins job (configured to invoke Nebula), building, testing, and packaging the source code. Libraries will have their .jar files pushed to the Netflix artifact repository, whereas applications will have their build artifact bundled into a debian package, which are pushed to the Netflix package repository, ready for “baking”.
    Onto baking: When a Jenkins job is successful, it typically triggers a Spinnaker pipeline. Spinnaker will read the operating system package generated by Nebula, and call the Bakery API to trigger a bake. As stated earlier, Netflix uses The Bakery to take from the package repository and create a new Amazon Machine Image. The Bakery exposes an API that facilitates the creation of AMIs globally. To trigger a bake, a user declares a package to be installed along with a foundation image on top of which the package will be installed. That foundation image, or Base AMI, provides a Linux environment customized with the common conventions, tools, and services required for seamless integration with the greater Netflix ecosystem. 
    Now that the bake is complete, Spinnaker makes the resultant AMI available for deployment to tens, hundreds, or thousands of instances. Multi-region deployment is made simple, as this AMI can be used in a variety of environments, due to the fact that Spinnaker exposes a runtime context to the application. This allows it to self-configure upon execution. Another team then checks the deployment using “a battery of automated tests.” 
    Last but not least, Netflix culture. At Netflix, both freedom and responsibility are emphasized in order to empower developers to create solutions for problems they think might need solving. However, for such a solution to become widely accepted, it must be compelling, add value, and reduce the cognitive load for other Netflix engineers. If a solution does catch on and sees wide use at Netflix, the team that created it is responsible for maintaining that solution, and tools offered by these teams are seen as a “Paved Road” of sorts by Netflix.
